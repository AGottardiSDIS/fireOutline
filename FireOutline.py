# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FireOutline
                                 A QGIS plugin
 FireOutline
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-10-19
        git sha              : $Format:%H$
        copyright            : (C) 2022 by FireOutline
        email                : agottardi@sdis34.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.gui import QgsMapToolEmitPoint, QgsMapTool, QgsMapToolEmitPoint, QgsRubberBand
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, pyqtSignal
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog
# Initialize Qt resources from file resources.py
from .resources import *
from qgis.core import QgsRasterLayer, QgsColorRampShader, QgsRasterShader, QgsSingleBandPseudoColorRenderer, QgsWkbTypes, QgsPointXY, QgsRectangle, QgsCoordinateReferenceSystem, QgsProject
# Import the code for the DockWidget
from .FireOutline_dockwidget import FireOutlineDockWidget
import os
import sys


import pathlib
import sys
import os.path
from datetime import datetime, timedelta, date


import platform
import subprocess
import sys

from .exceptions import show_message

#Recherche du path de OSGEO
A = sys.exec_prefix
B = A.split("\\")[:-2]
C = "\\".join(B) 
subprocess.call([C + "\OSGeo4W.bat","pip", "install", "sentinelhub"])

#Importation et/ou installations de biblioteque 
try:
    import sentinelhub
except ModuleNotFoundError:
    print('installing sentinelhub')
    if platform.system() == 'Windows':
        subprocess.call([C + "\OSGeo4W.bat","pip", "install", "sentinelhub"])
    else:
        subprocess.call(['python3', '-m', 'pip', 'install', 'sentinelhub'])
    import sentinelhub
try:
    import skimage
    from skimage import measure
    from skimage import filters
except ModuleNotFoundError:
    print('installing scikit-image')
    if platform.system() == 'Windows':
        subprocess.call([C + "\OSGeo4W.bat","pip", "install", 'scikit-image'])
    else:
        subprocess.call(['python3', '-m', 'pip', 'install', 'scikit-image'])
    import skimage
    from skimage import measure
    from skimage import filters

try:
    import pyproj
except ModuleNotFoundError:
    print('installing pyproj')
    if platform.system() == 'Windows':
        subprocess.call([C + "\OSGeo4W.bat","pip", "install", 'pyproj'])
    else:
        subprocess.call(['python3', '-m', 'pip', 'install', 'pyproj'])
    import pyproj

import json

from sentinelhub import SHConfig
from sentinelhub import (
    CRS,
    BBox,
    DataCollection,
    DownloadRequest,
    MimeType,
    MosaickingOrder,
    SentinelHubDownloadClient,
    SentinelHubRequest,
    bbox_to_dimensions,
    WmsRequest,
    WebFeatureService
)

try:
    import geopandas as gp
except ModuleNotFoundError:
    print('installing rasterio')
    if platform.system() == 'Windows':
        subprocess.call([sys.exec_prefix + '/python', "-m", 'pip', 'install', 'geopandas'])
    else:
        subprocess.call(['python3', '-m', 'pip', 'install', 'geopandas'])
    import geopandas as gp

from osgeo import gdal,osr,ogr
import numpy as np
import pandas as pd

from .constants import MessageType, CrsType, ImagePriority, ImageFormat, BaseUrl, ExtentType, ServiceType, TimeType, \
    AVAILABLE_SERVICE_TYPES, COVERAGE_MAX_BBOX_SIZE, ACTION_COOLDOWN, VECTOR_LAYER_COLOR_OPACITY
from .utils.geo import get_bbox, is_bbox_too_large, bbox_to_string, get_custom_bbox, is_current_map_crs


class FireOutline:

    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FireOutline_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FireOutline')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'FireOutline')
        self.toolbar.setObjectName(u'FireOutline')

        #print "** INITIALIZING FireOutline"

        self.pluginIsActive = False
        self.dockwidget = None




    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FireOutline', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/FireOutline/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING FireOutline"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD FireOutline"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FireOutline'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING FireOutline"
            #self.dockwidget.currentExtentRadioButton.clicked.connect(lambda: self.toggle_extent(ExtentType.CURRENT))


            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = FireOutlineDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.BottomDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            # Container of all widget
            self.dockwidget.Download_B.clicked.connect(self.tout_faire)
            self.dockwidget.connection_B.clicked.connect(self.test_connection)

            self.dockwidget.calendar.clicked.connect(self.add_calendar_date)

            self.dockwidget.folder_B.clicked.connect(self.select_download_folder)

            self.dockwidget.contour_b.clicked.connect(self.press_end)
            self.dockwidget.contour_b_2.clicked.connect(self.press_contour)

            #Instantiation of self global variable
            self.folder = ""
            self.calendar_time = ""

            self.lat_max = "0"
            self.lat_min = "0"
            self.lng_min = "0"
            self.lng_max = "0"

    def select_download_folder(self):
        # Opens a dialog to select a download folder
        
        self.folder = QFileDialog.getExistingDirectory(self.dockwidget, 'Select folder')
        self.dockwidget.folder_label.setText(self.folder)
        print(self.folder)
        
    def get_date(self, start_fire):
        '''
        Input: date départ de feu
        Output: 2 intervalles de temps (avant et après incendie) au format pour SentinelHub
        '''
        
        # nombre de jours d'ecart avec la date de depart de feu
        ecart_proche = 1
        ecart_loin = 15
        print(type(start_fire))
        if(type(start_fire) == list):
            start_fire = date(start_fire[0], start_fire[1], start_fire[2])

        if(type(start_fire) == str):
            res = []
            for i in start_fire.split("-"):
                res.append(int(i))
            start_fire = date(res[0], res[1], res[2])

        #Stockage des valeurs dans variables date...
            
        self.date_in_before = (start_fire - timedelta(days = ecart_loin)).strftime("%Y-%m-%d")
        self.date_out_before = (start_fire - timedelta(days = ecart_proche)).strftime("%Y-%m-%d")
        
        self.date_in_after = (start_fire + timedelta(days = ecart_proche)).strftime("%Y-%m-%d")
        self.date_out_after = (start_fire + timedelta(days = ecart_loin)).strftime("%Y-%m-%d")
        
    def find_files(self, filename, search_path):
        """
        Input : nom de fichier + path grand parent folder 
        Output : path global du fichier
        """
        result = []
        print(search_path)
        for root, dir, files in os.walk(search_path):
            if filename in files:
                result.append(os.path.join(root, filename))
        return result

    def get_img(self, date_in, date_out, box, name_out):
        '''
        Input: date debut et fin intervalle de prise d'image + nom de l'image satellite
        Output: enregistre .tiff du NBR sans nuage pendant la période mis en Input
        '''
        
        #Gestion de la box 
        betsiboka_coords_wgs84 = self.bbox_list
        resolution = 10
        betsiboka_bbox = BBox(bbox=betsiboka_coords_wgs84, crs=CRS.WGS84)
        betsiboka_size = bbox_to_dimensions(betsiboka_bbox, resolution=resolution)

        print(f"Image shape at {resolution} m resolution: {betsiboka_size} pixels")
        
        #Script sentinelHub pour récuperer dNBR (float32)
        #CLM correspond à la couche nuage
        evalscript_true_color = """
            //VERSION=3
            function setup() {
                return {
                    input: [{
                         bands: ["B12", "B08", "CLM"]
                    }],
                    output: {
                        bands: 1,
                        sampleType: SampleType.FLOAT32
                    }
                };
            }
            function evaluatePixel(sample) {
                if(sample.CLM == 0){
                    return [(sample.B12 - sample.B08) / (sample.B12 + sample.B08)];
                    }
                return [NaN]
            }
            """
        #Paramètres de téléchargement
        request_true_color = SentinelHubRequest(
            evalscript=evalscript_true_color,
            input_data=[
                SentinelHubRequest.input_data(
                    data_collection=DataCollection.SENTINEL2_L1C,
                    time_interval=(date_in, date_out),
                    mosaicking_order=MosaickingOrder.LEAST_CC,
                )
            ],
            #Export
            data_folder = f"{self.path}/all/",
            responses=[SentinelHubRequest.output_response("default", MimeType.TIFF)],
            bbox=betsiboka_bbox,
            size=betsiboka_size,
            config=self.config,
        )
        request_true_color.get_data(save_data = True)
        name = self.find_files("response.tiff",f"{self.path}/all/")
        print(name)
        
        #Déplacement des images dans un dossier choisit + changement de nom
        if os.path.exists(f'{self.path}/{name_out}.tiff'):
            os.remove(f'{self.path}/{name_out}.tiff')
        os.rename(name[0], f'{self.path}/{name_out}.tiff')

    def calcul_NBR(self):

        #Lecture des images dans un tableau
        after =  np.array(self.dataset_after.GetRasterBand(1).ReadAsArray())
        before = np.array(self.dataset_before.GetRasterBand(1).ReadAsArray())
                        
        #Calcul du dNBR 
        try:    
            print(after.shape)
            maska = np.ones(after.shape)
            maska[np.isnan(after)] = 0
            maska[np.isnan(before)] = 0
            
            if(after.mean() == before.mean()):
                print("Cherches pas c'est les memes")
            
            self.dNBR = after - before
            self.dNBR = self.dNBR * maska
            
        except Exception as e:
            print("Bug dans la matrice")
            print(e)
        
    def border_touch(self, arr):
        """
        Input: array of 1 and 0
        Output: bool True si 1 sur bordure; 0 si aucun 1 sur bordure
        """
        try:
            A = arr[0]
            if(A[0,:].max() or A[:,0].max() or A[len(A)-1,:].max() or A[:,len(A[0]) -1].max()):
                return(True)
            else:
                return(False)
        except:
            return(False)
        
    def get_label_max(self, labels, data_frame, dNBR):
        """
        Input : array label, df labels, array dnbr
        Output : n° label avec la valeur de dNBR la plus élevé parmis les 5 plus gros label en taille
        """
        sorted_data = list(data_frame.sort_values(by=['area'], ascending = False).label)[:5]
        label_max = 0
        value_max = 0

        for lab in sorted_data:
            tab = np.zeros(dNBR.shape)
            tab[labels == lab] = 1
            val = (tab * dNBR).max()   
            if(val > value_max):
                label_max = lab
                value_max = val

        return(label_max)
        
    def biggest(self):
        """ 
        Input: array dNBR (mapy) + le code d'intervention pour identifier si probleme
        Output: le plus grande zone dNBR > 0.1 avec ses proches voisins distant de (dist_voisin) case
        """
        dist_voisin = 6
        value_min_detect_feu = 0 #0.4 normalement_avec feu
        
        if(self.dNBR.max() > value_min_detect_feu):
            
            #Filtre le dNBR
            n_mask = np.zeros(self.dNBR.shape)
            n_mask[self.dNBR > 0.1] = 1
            
            #segmente toute les zones dNBR individuelle
            all_labels = measure.label(n_mask)
            props = measure.regionprops_table(all_labels, properties=['label', 'area', 'image'])
            data = pd.DataFrame(props) 
            
            #Récupère la plus grande zone 
            big_label = np.zeros(all_labels.shape)
            big_label[all_labels == list(data[data.area == data.area.max()].label)[0]] = 1
            
            #Récupère la zone avec le pixel le plus fort
            high_label = np.zeros(all_labels.shape)
            lab_max = self.get_label_max(all_labels, data, self.dNBR)
            high_label[all_labels == lab_max] = 1
            
            #Compare le label le plus fort et le plus grand
            if(np.array_equal(big_label, high_label)):
                choix = big_label
            elif(np.sum(high_label) > 10):
                choix = high_label
            else:
                choix = big_label
                
                
            
            #Agrandie cette zone de (dist_voisin)
            expend = skimage.segmentation.expand_labels(choix, dist_voisin)
            
            #Récupere toutes les zones adjacentes au dNBR principal
            mask_label = all_labels * expend
            list_value = list(np.unique(mask_label))
            list_value.remove(0)
            
            #Export des zones dans un raster
            result = np.zeros(all_labels.shape)
            for i in list_value:
                result[all_labels == i] = 1

            self.mask = result
        
        else:
            self.iface.messageBar().pushWarning("Warning", f"No fire detected in this area arround {self.calendar_time}")

    def area_nbr(self):
        '''
        Input: raster dNBR + raster mask
        Output: surfaces brulées pour chaque gravitées. 
        '''

        #100 m2 /pixel surface d'un pixel 
        #---------------------------------
        #!! A améliorer !!
        #---------------------------------

        coef_pixel = 100 / 10000
        
        tot_pixel = 0
        faible_pixel = 0
        modere_pixel = 0
        moyen_pixel = 0
        fort_pixel = 0
        
        print(self.dNBR.shape)
        print(self.mask.shape)
       
        
        try :
            if(self.mask is not None):
                self.dNBR = self.dNBR * self.mask
                for x in range(self.dNBR.shape[0]):
                    for y in range(self.dNBR.shape[1]):
                        if(self.dNBR[x,y] > 0.1 and self.dNBR[x,y] <= 0.27):
                            faible_pixel += 1            
                        if(self.dNBR[x,y] > 0.27 and self.dNBR[x,y] <= 0.44):
                            modere_pixel += 1
                        if(self.dNBR[x,y] > 0.44 and self.dNBR[x,y] <= 0.66):
                            moyen_pixel += 1
                        if(self.dNBR[x,y] > 0.66):
                            fort_pixel += 1

                tot_pixel = faible_pixel + modere_pixel + moyen_pixel + fort_pixel

            res = [tot_pixel*coef_pixel, faible_pixel*coef_pixel, modere_pixel*coef_pixel, moyen_pixel*coef_pixel, fort_pixel*coef_pixel]
        
        #Si problemes detectés renvoie 0 à chaques surface + affiche le probleme 
        except Exception as e:
            print(e)
            res = [tot_pixel, faible_pixel, modere_pixel, moyen_pixel, fort_pixel]

        self.value_burn = res

    def raster_mask(self, name):
        """
        Input : np.array du mask (0 et 1) + path stockage du .tiff
        Output : Raster georef du mask
        """
        cols,rows = self.mask.shape
        gt = self.dataset_before.GetGeoTransform()
        srs = osr.SpatialReference()
        epsg = 4326
        srs.ImportFromEPSG(epsg)
        srs = srs.ExportToWkt()
        # Initialize driver & create file
        driver = gdal.GetDriverByName('GTiff')
        dataset_out = driver.Create(f'{self.path}/{name}_mask.tiff',rows, cols, 1, gdal.GDT_Float64)
        dataset_out.SetGeoTransform(gt)
        dataset_out.SetProjection(srs)
        # Write file to disk
        dataset_out.GetRasterBand(1).WriteArray(np.int8(self.mask))
        dataset_out = None

    def vector_mask(self, name):
        #in_path = 'C:/Users/Adrien/Desktop/Sdis34/Contour de feu/Contour-de-feu/test_pour_C_bis.tiff'
        #out_path = 'C:/Users/Adrien/Desktop/Sdis34/Contour de feu/Contour-de-feu/test_pour_C_bisb.shp'

        #  get raster datasource
        src_ds = gdal.Open(f'{self.path}/{name}_mask.tiff')
        # open raster layer
        srcband = src_ds.GetRasterBand(1)

        #create layer output parameters
        dst_layername = 'burn'
        drv = ogr.GetDriverByName("ESRI Shapefile")
        dst_ds = drv.CreateDataSource(f'{self.path}/{name}_mask.shp')
        sp_ref = osr.SpatialReference()
        sp_ref.SetFromUserInput('EPSG:4326')
        dst_layer = dst_ds.CreateLayer(dst_layername, srs = sp_ref )
        fld = ogr.FieldDefn("HA", ogr.OFTInteger)
        dst_layer.CreateField(fld)
        dst_field = dst_layer.GetLayerDefn().GetFieldIndex("HA")

        #Polygonize le raster mask et l'integrer aux parametres d'entrés
        R = gdal.Polygonize( srcband, srcband, dst_layer, dst_field, [], callback=None )

        #vide la cache pour eviter surcharge CPU
        del src_ds
        del dst_ds

    import json

    def export_gpkg(self, name):
        '''
        Input: nom d'un .shp
        Output: tous les element du .shp en 1 couche de .gpkg + valeurs de surfaces brulées
        '''

        #Lecture du .shp
        R = ogr.Open(f'{self.path}/{name}_mask.shp')
        T = R.GetLayer(0)

        #Liste de toutes les formes polygon du .shp
        all_poly = []
        for feat in T:
            geom = feat.geometry()
            j_geom = geom.ExportToJson()
            value = json.loads(j_geom)["coordinates"]
            all_poly.append(value)
        
        #création du dict du gpkg 
        resultsb = ({'properties': {'area_ha' : self.value_burn[0], 
                            'area_low_severity_ha' : self.value_burn[1], 
                            'area_moderate_severity_ha' : self.value_burn[2], 
                            'area_miderate_severity_ha' : self.value_burn[3],
                            'area_high_severity_ha':self.value_burn[4]}, 
                     'geometry': {"type" : "MultiPolygon", 'coordinates':all_poly}})

        # Exportation des vecteurs en gpkg
        gpd_polygonized_raster  = gp.GeoDataFrame.from_features([resultsb])
        gpd_polygonized_raster.set_crs(epsg=4326, inplace=True)
        gpd_polygonized_raster.to_file(f'{self.path}/{name}_contour_final.gpkg')

    def export_dNBR(self, name):
        """
        Input : np.array du mask (0 et 1) + path stockage du .tiff
        Output : Raster georeférencé du du dNBR en .tiff
        """

        #Paramètre du raster
        cols,rows = self.dNBR.shape
        gt = self.dataset_before.GetGeoTransform()
        srs = osr.SpatialReference()
        epsg = 4326
        srs.ImportFromEPSG(epsg)
        srs = srs.ExportToWkt()

        # Initialize driver & create file
        driver = gdal.GetDriverByName('GTiff')
        dataset_out = driver.Create(f'{self.path}/{name}_dNBR.tiff',rows, cols, 1, gdal.GDT_Float64)
        dataset_out.SetGeoTransform(gt)
        dataset_out.SetProjection(srs)

        # Write file to disk
        dataset_out.GetRasterBand(1).WriteArray(np.float64(self.dNBR))
        dataset_out = None  

    def coloring(self):
        """
        Actualise la colormap Qgis du dNBR pour coloration usuelle
        """

        #Creation de la colormap
        fcn = QgsColorRampShader()
        fcn.setColorRampType(QgsColorRampShader.Discrete)
        fcn.setClassificationMode(QgsColorRampShader.Continuous)
        lst = [QgsColorRampShader.ColorRampItem(-0.25, QColor(47,188,52,0),"High Regrowth"),
            QgsColorRampShader.ColorRampItem(-0.1,QColor(58,255,120,0),'Low Regrowth'), 
            QgsColorRampShader.ColorRampItem(0.1,QColor(35,255,226,0),"Unburned"), 
            QgsColorRampShader.ColorRampItem(0.27,QColor(252,255,69,255),"Low Severity"), 
            QgsColorRampShader.ColorRampItem(0.44,QColor(255,205,78,255),"Moderate Severity"), 
            QgsColorRampShader.ColorRampItem(0.66,QColor(255,104,21,255),"Miderate Severity"), 
            QgsColorRampShader.ColorRampItem(1.3,QColor(255,16,243,255),"High Severity")
                 ]

        #Application de la colormap
        fcn.setColorRampItemList(lst)
        shader = QgsRasterShader()
        shader.setRasterShaderFunction(fcn)
        renderer = QgsSingleBandPseudoColorRenderer(self.dNBR_layer.dataProvider(), 1, shader)
        self.dNBR_layer.setRenderer(renderer)
        self.dNBR_layer.triggerRepaint()  

    def tout_faire(self, name_fire = "Gignac", path = "C:/Users/Adrien/Desktop/Sdis34/Contour de feu/Output_test_Qgis"):
        """
            Processus global après appuis sur 'Download'
        """

        #Stockage du nom du feu
        name_fire = self.dockwidget.name_fire.text()
        import random
        
        #Vérification des imputs calendar, nom de feu, dossier output valides
        if(self.calendar_time == ""):
            self.iface.messageBar().pushCritical("Critical", f"No date selected")
            return

        r1 = random.randint(1, 1000)
        if(name_fire == ""):
            name_fire = "No_name_fire_" + str(r1)
            self.iface.messageBar().pushInfo("Info", f"No fire name in input : it will be refferenced as {name_fire}")
        
        if(self.folder == ""):
            self.iface.messageBar().pushCritical("Critical", f"No folder selected")
            return
        else:
            self.path = self.folder

        if os.path.exists(f'{self.path}/{name_fire}_af.tiff'):
            name_fire = name_fire + str(r1)
            self.iface.messageBar().pushInfo("Info", f"{self.dockwidget.name_fire.text()} already exist : new name : {name_fire}")


        #Load cred
        self.test_connection()
        #Check si zone d'etude valide
        self.get_box()
        if(self.bbox_list[0] == self.bbox_list[1]):
            self.iface.messageBar().pushCritical("Critical", f"No area of study selected")
            return

        #Calcul les jours 
        self.get_date(self.calendar_time)
        #Download les images NBR sentinel
        try:
            self.iface.messageBar().pushInfo("Start calcul", f"Please_wait")
            self.get_img(self.date_in_before, self.date_out_before, self.bbox_list, f"{name_fire}_bf")
            self.get_img(self.date_in_after, self.date_out_after, self.bbox_list, f"{name_fire}_af")
        except Exception as e:
            print(e)
            self.iface.messageBar().pushCritical("Critical", f"Area to large : zoom and retry")
            return
        #Open NBR in QGIS
        #self.layer_before = self.iface.addRasterLayer(f"{self.path}/{name_fire}_bf.tiff", f"NBR_Before_{name_fire}")
        #self.layer_after = self.iface.addRasterLayer(f"{self.path}/{name_fire}_af.tiff", "NBR_After")

        #self.layer_before.setItemVisibilityChecked(False)
        #self.layer_after.setItemVisibilityChecked(False)

        #Open dataset NBR with gdal
        self.dataset_before = gdal.Open(f"{self.path}/{name_fire}_bf.tiff", gdal.GA_ReadOnly)
        self.dataset_after = gdal.Open(f"{self.path}/{name_fire}_af.tiff", gdal.GA_ReadOnly)
        #Calcul dNBR
        self.calcul_NBR()
        #Calcul mask
        self.biggest()
        #Calcul air brulee
        self.area_nbr()
        #export dNBR
        self.export_dNBR(name_fire)
        #export mask raster
        self.raster_mask(name_fire)
        #export mask shp
        self.vector_mask(name_fire)
        #export gpkg
        self.export_gpkg(name_fire)
        #Open dNBR on Qgis
        self.dNBR_layer = self.iface.addRasterLayer(f"{self.path}/{name_fire}_dNBR.tiff", f"dNBR_{name_fire}")
        self.mask_layer = self.iface.addVectorLayer (f'{self.path}/{name_fire}_contour_final.gpkg', f"", "ogr")
        #Colormap du dNBR
        self.coloring()
    


    def test_connection(self):
        """Test de connection au serveur SentinelHub"""
        self.load_credential()
        #Connexion SentinelHub
        self.config = SHConfig()
        self.config.instance_id = self.sentinel_ID
        self.config.sh_client_id = self.sentinel_ID
        self.config.sh_client_secret = self.sentinel_PSW
        
        #Test connexion
        if not self.config.sh_client_id or not self.config.sh_client_secret:
            print("Warning! To use Process API, please provide the credentials (OAuth client ID and client secret).")
        else:
            print("Let's go la conection")


    def load_credential(self):
        """Vérification des login / mdp de sentinelhub"""
        #------------------------------

        #Ne pas oublier

        #-------------------------------
        #self.sentinel_ID = self.dockwidget.id_enter.text()
        #self.sentinel_PSW = self.dockwidget.psw_enter.text()

        self.sentinel_ID = "b04a4ee7-5417-4318-912e-1fb21e29a65c"
        self.sentinel_PSW = "Hv[cs0xe>%l.a7DTG1n1e{6reApKRooKX&?G<^)I"

    def add_calendar_date(self):
        """ Handles selected calendar date
        """
        self.calendar_time = str(self.dockwidget.calendar.selectedDate().toPyDate())
        print(self.calendar_time)

    def set_window_bbox(self):
        """ Retourne les coordonnées de la boite Qgis
        """
        bbox = get_bbox(CrsType.WGS84)
        self.bbox_list = bbox_to_string(bbox, CrsType.WGS84).split(',')


        self.lat_min = self.bbox_list[0]
        self.lng_min = self.bbox_list[1]
        self.lat_max = self.bbox_list[2]
        self.lng_max = self.bbox_list[3]

        self.actual_box()        

    def actual_box(self):
        self.dockwidget.lat_min_t.setText(self.lat_min)
        self.dockwidget.lat_max_t.setText(self.lat_max)

        self.dockwidget.long_t_min.setText(self.lng_min)
        self.dockwidget.long_t_max.setText(self.lng_max)

        self.bbox_list = [self.lng_min, self.lat_min, self.lng_max, self.lat_max]

        print(self.bbox_list)

    def press_contour(self):
        print("En cours")
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(4326))
        self.tool = RectangleMapTool(self.iface.mapCanvas(), self)
        self.iface.mapCanvas().setMapTool(self.tool)

    def end_tool(self):
        self.iface.mapCanvas().unsetMapTool(self.tool)

    def press_end(self):        
        self.set_window_bbox()

    def get_box(self):
        self.bbox_list = [self.dockwidget.long_t_min.text(), self.dockwidget.lat_min_t.text(), self.dockwidget.long_t_max.text(), self.dockwidget.lat_max_t.text()]



class RectangleMapTool(QgsMapTool):
    def __init__(self, canvas, fire):
        self.canvas = canvas
        self.fire = fire
        QgsMapTool.__init__(self, self.canvas)
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(1)
        self.reset()
  
    def reset(self):
        self.startPoint = self.endPoint = None
        self.isEmittingPoint = False
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
  
    def canvasPressEvent(self, e):
        self.startPoint = self.toMapCoordinates(e.pos())
        self.endPoint = self.startPoint
        self.isEmittingPoint = True
        self.showRect(self.startPoint, self.endPoint)
  
    def canvasReleaseEvent(self, e):
        self.isEmittingPoint = False
        r = self.rectangle()
        if r is not None:
          print("Rectangle:", r.xMinimum(),
                r.yMinimum(), r.xMaximum(), r.yMaximum()
               )

        self.fire.lat_min = str(r.yMinimum())[:8]
        self.fire.lng_min = str(r.xMinimum())[:8]
        self.fire.lat_max = str(r.yMaximum())[:8]
        self.fire.lng_max = str(r.xMaximum())[:8]

        self.fire.actual_box()

        self.reset()
        self.deactivate()
        self.fire.end_tool()
  
    def canvasMoveEvent(self, e):
        if not self.isEmittingPoint:
          return
    
        self.endPoint = self.toMapCoordinates(e.pos())
        self.showRect(self.startPoint, self.endPoint)
  
    def showRect(self, startPoint, endPoint):
        self.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
        if startPoint.x() == endPoint.x() or startPoint.y() == endPoint.y():
          return
    
        point1 = QgsPointXY(startPoint.x(), startPoint.y())
        point2 = QgsPointXY(startPoint.x(), endPoint.y())
        point3 = QgsPointXY(endPoint.x(), endPoint.y())
        point4 = QgsPointXY(endPoint.x(), startPoint.y())
    
        self.rubberBand.addPoint(point1, False)
        self.rubberBand.addPoint(point2, False)
        self.rubberBand.addPoint(point3, False)
        self.rubberBand.addPoint(point4, True)    # true to update canvas
        self.rubberBand.show()
  
    def rectangle(self):
        if self.startPoint is None or self.endPoint is None:
            return None
        elif (self.startPoint.x() == self.endPoint.x() or \
              self.startPoint.y() == self.endPoint.y()):
            return None
    
        return QgsRectangle(self.startPoint, self.endPoint)
  
    def deactivate(self):
        print("desactivation")
        #option 1:
        super().deactivate()

        QgsMapTool.deactivate(self)
        self.deactivated.emit()  
        
        